#!/usr/bin/env python3
"""
Add initial example samples to get started.

This script adds a few example samples (OSS, LLM-generated, and bad code)
to demonstrate the dataset structure.
"""

import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from scripts.curate_dataset import DatasetCurator


def main():
    """Add initial example samples."""
    curator = DatasetCurator()
    curator.create_metadata_csv()

    print("Adding initial example samples...\n")

    # ===== OPEN-SOURCE SAMPLE =====
    print("1. Adding OSS sample (good utility function)...")
    curator.add_sample(
        sample_id='oss_001',
        code_content='''
def validate_email(email: str) -> bool:
    """Validate email address format using regex.
    
    Args:
        email: Email address string to validate
        
    Returns:
        True if email format is valid, False otherwise
    """
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))
''',
        source='github',
        category='utility',
        quality_expectation='good',
        description='Email validation function with regex',
        source_url='https://github.com/example/repo',
        author='Open Source Contributor',
        license='MIT',
        complexity='low',
    )

    # ===== LLM-GENERATED SAMPLE =====
    print("2. Adding LLM-generated sample (good code)...")
    curator.add_sample(
        sample_id='llm_001',
        code_content='''
def calculate_fibonacci(n: int) -> int:
    """Calculate the nth Fibonacci number efficiently.
    
    Uses iterative approach for O(n) time complexity.
    
    Args:
        n: Non-negative integer representing position in sequence
        
    Returns:
        The nth Fibonacci number
        
    Raises:
        ValueError: If n is negative
    """
    if n < 0:
        raise ValueError("Fibonacci sequence is not defined for negative numbers")
    if n < 2:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b
''',
        source='llm_generated',
        category='utility',
        quality_expectation='good',
        description='Efficient Fibonacci calculator (generated by Claude)',
        author='Claude 3.5 Sonnet',
        complexity='low',
    )

    # ===== INTENTIONALLY BAD SAMPLE =====
    print("3. Adding intentionally bad sample...")
    curator.add_sample(
        sample_id='bad_001',
        code_content='''
def f(d):
    x = []
    for k in d:
        if isinstance(d[k], list):
            for i in range(len(d[k])):
                if d[k][i] > 0 and d[k][i] < 100:
                    x.append(d[k][i] * 2)
    return x
''',
        source='intentionally_bad',
        category='data_processing',
        quality_expectation='bad',
        description='Poor variable names and inefficient nested loops',
        complexity='medium',
        notes='Violates: naming conventions, efficiency, code clarity',
    )

    # ===== ANOTHER LLM SAMPLE =====
    print("4. Adding another LLM-generated sample...")
    curator.add_sample(
        sample_id='llm_002',
        code_content='''
def merge_sorted_arrays(arr1: list, arr2: list) -> list:
    """Merge two sorted arrays into a single sorted array.
    
    Args:
        arr1: First sorted array
        arr2: Second sorted array
        
    Returns:
        Merged sorted array
    """
    result = []
    i = j = 0
    
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    
    # Add remaining elements
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    
    return result
''',
        source='llm_generated',
        category='utility',
        quality_expectation='good',
        description='Merge two sorted arrays (GPT-4 generated)',
        author='GPT-4',
        complexity='medium',
    )

    # ===== ANOTHER BAD SAMPLE =====
    print("5. Adding another bad sample (missing error handling)...")
    curator.add_sample(
        sample_id='bad_002',
        code_content='''
def divide(a, b):
    return a / b
''',
        source='intentionally_bad',
        category='utility',
        quality_expectation='bad',
        description='Missing error handling for division by zero',
        complexity='low',
        notes='Violates: error handling, input validation',
    )

    print("\n" + "=" * 60)
    print(f"âœ“ Successfully added {curator.get_sample_count()} samples!")
    print("=" * 60)
    print("\nSample breakdown:")
    curator.list_samples()

    print("\n" + "=" * 60)
    print("Next steps:")
    print("1. Review the samples in: datasets/original_code/")
    print("2. Add more samples using: python scripts/add_samples_interactive.py")
    print("3. Or add programmatically using the DatasetCurator class")
    print("=" * 60)


if __name__ == "__main__":
    main()
